-- This file is used to test mpp pusdown.
-- ===================================================================
-- create FDW objects
-- ===================================================================
SET timezone = 'PST8PDT';
SET optimizer_trace_fallback = on;
SET optimizer = off;
-- If gp_enable_minmax_optimization is on, it won't generate aggregate functions pushdown plan.
SET gp_enable_minmax_optimization = off;
-- Clean
-- start_ignore
DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
NOTICE:  drop cascades to 55 other objects
DETAIL:  drop cascades to server testserver1
drop cascades to user mapping for public on server testserver1
drop cascades to server pgserver
drop cascades to user mapping for gpadmin on server pgserver
drop cascades to foreign table ft1
drop cascades to foreign table ft2
drop cascades to foreign table ft4
drop cascades to foreign table ft5
drop cascades to foreign table ft3
drop cascades to foreign table rem1
drop cascades to foreign table grem1
drop cascades to foreign table rem2
drop cascades to foreign table import_dest1.t1
drop cascades to foreign table import_dest1.t2
drop cascades to foreign table import_dest1.t3
drop cascades to foreign table import_dest1.t4
drop cascades to foreign table import_dest1."x 4"
drop cascades to foreign table import_dest1."x 5"
drop cascades to foreign table import_dest1."x 6"
drop cascades to foreign table import_dest2.t1
drop cascades to foreign table import_dest2.t2
drop cascades to foreign table import_dest2.t3
drop cascades to foreign table import_dest2.t4
drop cascades to foreign table import_dest2."x 4"
drop cascades to foreign table import_dest2."x 5"
drop cascades to foreign table import_dest2."x 6"
drop cascades to foreign table import_dest3.t1
drop cascades to foreign table import_dest3.t2
drop cascades to foreign table import_dest3.t3
drop cascades to foreign table import_dest3.t4
drop cascades to foreign table import_dest3."x 4"
drop cascades to foreign table import_dest3."x 5"
drop cascades to foreign table import_dest3."x 6"
drop cascades to foreign table import_dest4.t1
drop cascades to foreign table import_dest4.t2
drop cascades to foreign table import_dest4.t3
drop cascades to foreign table import_dest4.t4
drop cascades to foreign table import_dest4."x 5"
drop cascades to foreign table import_dest4."x 6"
drop cascades to foreign table ftprt1_p1
drop cascades to foreign table ftprt1_p2
drop cascades to foreign table ftprt2_p1
drop cascades to foreign table ftprt2_p2
drop cascades to foreign table fpagg_tab_p1
drop cascades to foreign table fpagg_tab_p2
drop cascades to foreign table fpagg_tab_p3
drop cascades to server pgserver2
drop cascades to user mapping for gpadmin on server pgserver2
drop cascades to foreign table ft6
drop cascades to server loopback
drop cascades to user mapping for gpadmin on server loopback
drop cascades to foreign table postgres_fdw_gp.gp_ft1
drop cascades to foreign table postgres_fdw_gp.gp_all
drop cascades to foreign table postgres_fdw_gp.gp_any
drop cascades to foreign table postgres_fdw_gp.gp_coord
-- end_ignore
CREATE EXTENSION postgres_fdw;
CREATE SERVER pgserver FOREIGN DATA WRAPPER postgres_fdw
  OPTIONS (dbname 'contrib_regression', multi_hosts 'localhost localhost',
           multi_ports '5432 5555', num_segments '2', mpp_execute 'multi servers');
CREATE USER MAPPING FOR CURRENT_USER SERVER pgserver;
-- ===================================================================
-- create objects used through FDW pgserver server
-- ===================================================================
-- remote postgres server 1 -- listening port 5432
\! env PGOPTIONS='' psql -p 5432 contrib_regression -f sql/postgres_sql/mpp_gp2pg_postgres_init_1.sql
SET
CREATE SCHEMA
CREATE TABLE
CREATE TABLE
ALTER TABLE
ALTER TABLE
INSERT 0 500
UPDATE 500
ANALYZE
-- remote postgres server 2 -- listening port 5555
\! env PGOPTIONS='' psql -p 5555 contrib_regression -f sql/postgres_sql/mpp_gp2pg_postgres_init_2.sql
SET
CREATE SCHEMA
CREATE TABLE
CREATE TABLE
ALTER TABLE
ALTER TABLE
INSERT 0 500
UPDATE 500
ANALYZE
-- ===================================================================
-- create foreign tables
-- ===================================================================
CREATE FOREIGN TABLE mpp_ft1 (
	c1 int,
	c2 int,
	c3 smallint,
	c4 bigint,
	c5 real,
	c6 double precision,
	c7 numeric
) SERVER pgserver OPTIONS (schema_name 'MPP_S 1', table_name 'T 1');
CREATE FOREIGN TABLE mpp_ft2 (
	c1 int,
	c2 int
) SERVER pgserver OPTIONS (schema_name 'MPP_S 1', table_name 'T 2');
-- ===================================================================
-- tests for validator
-- ===================================================================
CREATE SERVER testserver FOREIGN DATA WRAPPER postgres_fdw
  OPTIONS (dbname 'contrib_regression', multi_hosts 'localhost localhost',
           multi_ports '5432 5432', num_segments '2', mpp_execute 'all segments');
ERROR:  If mpp_execute != "multi servers", multi_hosts and multi_ports are invalid options.
CREATE SERVER testserver FOREIGN DATA WRAPPER postgres_fdw
  OPTIONS (dbname 'contrib_regression', multi_hosts 'localhost localhost',
           multi_ports '5432', num_segments '2', mpp_execute 'multi servers');
ERROR:  server option num_segments, multi_hosts and multi_ports don't match.
CREATE SERVER testserver FOREIGN DATA WRAPPER postgres_fdw
  OPTIONS (dbname 'contrib_regression', multi_hosts 'localhost localhost',
           multi_ports '5432 5432', num_segments '1', mpp_execute 'multi servers');
ERROR:  server option num_segments, multi_hosts and multi_ports don't match.
CREATE FOREIGN TABLE mpp_test (
	c1 int,
	c2 int
) SERVER pgserver OPTIONS (mpp_execute 'multi servers');
ERROR:  Only when CREATE SERVER, mpp_execute can be set to "multi servers"  (seg2 127.0.0.1:7004 pid=21970)
-- ===================================================================
-- Simple queries
-- ===================================================================
EXPLAIN VERBOSE SELECT * FROM mpp_ft1;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=100.00..2330.00 rows=71000 width=62)
   Output: c1, c2, c3, c4, c5, c6, c7
   ->  Foreign Scan on public.mpp_ft1  (cost=100.00..1265.00 rows=35500 width=62)
         Output: c1, c2, c3, c4, c5, c6, c7
         Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7 FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(7 rows)

ALTER FOREIGN TABLE mpp_ft1 OPTIONS (add use_remote_estimate 'true');
EXPLAIN VERBOSE SELECT * FROM mpp_ft1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=100.00..176.00 rows=2000 width=32837)
   Output: c1, c2, c3, c4, c5, c6, c7
   ->  Foreign Scan on public.mpp_ft1  (cost=100.00..146.00 rows=1000 width=32837)
         Output: c1, c2, c3, c4, c5, c6, c7
         Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7 FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(7 rows)

ALTER FOREIGN TABLE mpp_ft1 OPTIONS (drop use_remote_estimate);
-- ===================================================================
-- Aggregate and grouping queries
-- ===================================================================
-- Simple aggregates with different data types
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(c1), count(c3), count(c4), count(c5), count(c6), count(c7) FROM mpp_ft1;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(c1), count(c3), count(c4), count(c5), count(c6), count(c7)
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL count(c1)), (PARTIAL count(c3)), (PARTIAL count(c4)), (PARTIAL count(c5)), (PARTIAL count(c6)), (PARTIAL count(c7))
         ->  Foreign Scan
               Output: (PARTIAL count(c1)), (PARTIAL count(c3)), (PARTIAL count(c4)), (PARTIAL count(c5)), (PARTIAL count(c6)), (PARTIAL count(c7))
               Relations: Aggregate on (public.mpp_ft1)
               Remote SQL: SELECT count(c1), count(c3), count(c4), count(c5), count(c6), count(c7) FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(10 rows)

SELECT count(c1), count(c3), count(c4), count(c5), count(c6), count(c7) FROM mpp_ft1;
 count | count | count | count | count | count 
-------+-------+-------+-------+-------+-------
  1000 |  1000 |  1000 |  1000 |  1000 |  1000
(1 row)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT sum(c1), sum(c3), sum(c4), sum(c5), sum(c6), sum(c7) FROM mpp_ft1;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: sum(c1), sum(c3), sum(c4), sum(c5), sum(c6), sum(c7)
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL sum(c1)), (PARTIAL sum(c3)), (PARTIAL sum(c4)), (PARTIAL sum(c5)), (PARTIAL sum(c6)), (PARTIAL sum(c7))
         ->  Foreign Scan
               Output: (PARTIAL sum(c1)), (PARTIAL sum(c3)), (PARTIAL sum(c4)), (PARTIAL sum(c5)), (PARTIAL sum(c6)), (PARTIAL sum(c7))
               Relations: Aggregate on (public.mpp_ft1)
               Remote SQL: SELECT sum(c1), sum(c3), sum(c4), sum(c5), sum(c6), sum(c7) FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(10 rows)

SELECT sum(c1), sum(c3), sum(c4), sum(c5), sum(c6), sum(c7) FROM mpp_ft1;
  sum   |  sum   |  sum   |  sum  |        sum        |   sum   
--------+--------+--------+-------+-------------------+---------
 500500 | 500500 | 500500 | 500.5 | 500.5000000000001 | 500.500
(1 row)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT avg(c1), avg(c3), avg(c4), avg(c5), avg(c6), avg(c7) FROM mpp_ft1;
                                                                                                                              QUERY PLAN                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: avg(c1), avg(c3), avg(c4), avg(c5), avg(c6), avg(c7)
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL avg(c1)), (PARTIAL avg(c3)), (PARTIAL avg(c4)), (PARTIAL avg(c5)), (PARTIAL avg(c6)), (PARTIAL avg(c7))
         ->  Foreign Scan
               Output: (PARTIAL avg(c1)), (PARTIAL avg(c3)), (PARTIAL avg(c4)), (PARTIAL avg(c5)), (PARTIAL avg(c6)), (PARTIAL avg(c7))
               Relations: Aggregate on (public.mpp_ft1)
               Remote SQL: SELECT array[count(c1), sum(c1)], array[count(c3), sum(c3)], array[count(c4), sum(c4)], array[count(c5), sum(c5), count(c5)*var_pop(c5)], array[count(c6), sum(c6), count(c6)*var_pop(c6)], array[count(c7), sum(c7)] FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(10 rows)

SELECT avg(c1), avg(c3), avg(c4), avg(c5), avg(c6), avg(c7) FROM mpp_ft1;
         avg          |         avg          |         avg          |  avg   |        avg         |          avg           
----------------------+----------------------+----------------------+--------+--------------------+------------------------
 500.5000000000000000 | 500.5000000000000000 | 500.5000000000000000 | 0.5005 | 0.5005000000000002 | 0.50050000000000000000
(1 row)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT min(c1), min(c3), min(c4), min(c5), min(c6), min(c7) FROM mpp_ft1;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: min(c1), min(c3), min(c4), min(c5), min(c6), min(c7)
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL min(c1)), (PARTIAL min(c3)), (PARTIAL min(c4)), (PARTIAL min(c5)), (PARTIAL min(c6)), (PARTIAL min(c7))
         ->  Foreign Scan
               Output: (PARTIAL min(c1)), (PARTIAL min(c3)), (PARTIAL min(c4)), (PARTIAL min(c5)), (PARTIAL min(c6)), (PARTIAL min(c7))
               Relations: Aggregate on (public.mpp_ft1)
               Remote SQL: SELECT min(c1), min(c3), min(c4), min(c5), min(c6), min(c7) FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(10 rows)

SELECT min(c1), min(c3), min(c4), min(c5), min(c6), min(c7) FROM mpp_ft1;
 min | min | min |  min  |  min  |  min  
-----+-----+-----+-------+-------+-------
   1 |   1 |   1 | 0.001 | 0.001 | 0.001
(1 row)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT max(c1), max(c3), max(c4), max(c5), max(c6), max(c7) FROM mpp_ft1;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: max(c1), max(c3), max(c4), max(c5), max(c6), max(c7)
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL max(c1)), (PARTIAL max(c3)), (PARTIAL max(c4)), (PARTIAL max(c5)), (PARTIAL max(c6)), (PARTIAL max(c7))
         ->  Foreign Scan
               Output: (PARTIAL max(c1)), (PARTIAL max(c3)), (PARTIAL max(c4)), (PARTIAL max(c5)), (PARTIAL max(c6)), (PARTIAL max(c7))
               Relations: Aggregate on (public.mpp_ft1)
               Remote SQL: SELECT max(c1), max(c3), max(c4), max(c5), max(c6), max(c7) FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(10 rows)

SELECT max(c1), max(c3), max(c4), max(c5), max(c6), max(c7) FROM mpp_ft1;
 max  | max  | max  | max | max |  max  
------+------+------+-----+-----+-------
 1000 | 1000 | 1000 |   1 |   1 | 1.000
(1 row)

-- Simple Aggregates with GROUP BY clause
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(c1), sum(c3), avg(c4), min(c5), max(c6), count(c1) * (random() <= 1)::int as count2 FROM mpp_ft1 GROUP BY c2 ORDER BY c2;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: (count(c1)), (sum(c3)), (avg(c4)), (min(c5)), (max(c6)), (((count(c1)) * ((random() <= '1'::double precision))::integer)), c2
   Merge Key: c2
   ->  Result
         Output: (count(c1)), (sum(c3)), (avg(c4)), (min(c5)), (max(c6)), ((count(c1)) * ((random() <= '1'::double precision))::integer), c2
         ->  Sort
               Output: (count(c1)), (sum(c3)), (avg(c4)), (min(c5)), (max(c6)), c2
               Sort Key: mpp_ft1.c2
               ->  Finalize HashAggregate
                     Output: count(c1), sum(c3), avg(c4), min(c5), max(c6), c2
                     Group Key: mpp_ft1.c2
                     ->  Redistribute Motion 2:3  (slice2; segments: 2)
                           Output: c2, (PARTIAL count(c1)), (PARTIAL sum(c3)), (PARTIAL avg(c4)), (PARTIAL min(c5)), (PARTIAL max(c6))
                           Hash Key: c2
                           ->  Foreign Scan
                                 Output: c2, (PARTIAL count(c1)), (PARTIAL sum(c3)), (PARTIAL avg(c4)), (PARTIAL min(c5)), (PARTIAL max(c6))
                                 Relations: Aggregate on (public.mpp_ft1)
                                 Remote SQL: SELECT c2, count(c1), sum(c3), array[count(c4), sum(c4)], min(c5), max(c6) FROM "MPP_S 1"."T 1" GROUP BY 1
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(20 rows)

SELECT count(c1), sum(c3), avg(c4), min(c5), max(c6), count(c1) * (random() <= 1)::int as count2 FROM mpp_ft1 GROUP BY c2 ORDER BY c2;
 count |  sum  |         avg          |  min  |  max  | count2 
-------+-------+----------------------+-------+-------+--------
   100 | 50500 | 505.0000000000000000 |  0.01 |     1 |    100
   100 | 49600 | 496.0000000000000000 | 0.001 | 0.991 |    100
   100 | 49700 | 497.0000000000000000 | 0.002 | 0.992 |    100
   100 | 49800 | 498.0000000000000000 | 0.003 | 0.993 |    100
   100 | 49900 | 499.0000000000000000 | 0.004 | 0.994 |    100
   100 | 50000 | 500.0000000000000000 | 0.005 | 0.995 |    100
   100 | 50100 | 501.0000000000000000 | 0.006 | 0.996 |    100
   100 | 50200 | 502.0000000000000000 | 0.007 | 0.997 |    100
   100 | 50300 | 503.0000000000000000 | 0.008 | 0.998 |    100
   100 | 50400 | 504.0000000000000000 | 0.009 | 0.999 |    100
(10 rows)

-- Aggregate is not pushed down as aggregation contains random()
EXPLAIN (VERBOSE, COSTS OFF)
SELECT sum(c1 * (random() <= 1)::int) as sum, avg(c1) FROM mpp_ft1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: sum((c1 * ((random() <= '1'::double precision))::integer)), avg(c1)
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL sum((c1 * ((random() <= '1'::double precision))::integer))), (PARTIAL avg(c1))
         ->  Partial Aggregate
               Output: PARTIAL sum((c1 * ((random() <= '1'::double precision))::integer)), PARTIAL avg(c1)
               ->  Foreign Scan on public.mpp_ft1
                     Output: c1, c2, c3, c4, c5, c6, c7
                     Remote SQL: SELECT c1 FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(11 rows)

SELECT sum(c1 * (random() <= 1)::int) as sum, avg(c1) FROM mpp_ft1;
  sum   |         avg          
--------+----------------------
 500500 | 500.5000000000000000
(1 row)

-- GROUP BY clause having expressions
/* FIXME: Aggregates are not pushed down.
          Because for Remote SQL of partial agg, non-grouping columns 
		  might neither appear in the GROUP BY clause nor be used in 
		  an aggregate function.
		  This is unsafe to make foreign grouping.
*/
EXPLAIN (VERBOSE, COSTS OFF)
SELECT c2/2, sum(c2) * (c2/2) FROM mpp_ft1 GROUP BY c2/2 ORDER BY c2/2;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: ((c2 / 2)), ((sum(c2) * ((c2 / 2))))
   Merge Key: ((c2 / 2))
   ->  Sort
         Output: ((c2 / 2)), ((sum(c2) * ((c2 / 2))))
         Sort Key: ((mpp_ft1.c2 / 2))
         ->  Finalize HashAggregate
               Output: ((c2 / 2)), (sum(c2) * ((c2 / 2)))
               Group Key: ((mpp_ft1.c2 / 2))
               ->  Redistribute Motion 2:3  (slice2; segments: 2)
                     Output: ((c2 / 2)), (PARTIAL sum(c2)), c2
                     Hash Key: ((c2 / 2))
                     ->  Partial HashAggregate
                           Output: ((c2 / 2)), PARTIAL sum(c2), c2
                           Group Key: (mpp_ft1.c2 / 2)
                           ->  Foreign Scan on public.mpp_ft1
                                 Output: (c2 / 2), c2
                                 Remote SQL: SELECT c2 FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(20 rows)

SELECT c2/2, sum(c2) * (c2/2) FROM mpp_ft1 GROUP BY c2/2 ORDER BY c2/2;
 ?column? | ?column? 
----------+----------
        0 |        0
        1 |      500
        2 |     1800
        3 |     3900
        4 |     6800
(5 rows)

-- Aggregates in subquery are pushed down.
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(x.a), sum(x.a) FROM (SELECT c2 a, sum(c1) b FROM mpp_ft1 GROUP BY c2, sqrt(c1) ORDER BY 1, 2) x;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(mpp_ft1.c2), sum(mpp_ft1.c2)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(mpp_ft1.c2)), (PARTIAL sum(mpp_ft1.c2))
         ->  Partial Aggregate
               Output: PARTIAL count(mpp_ft1.c2), PARTIAL sum(mpp_ft1.c2)
               ->  Sort
                     Output: mpp_ft1.c2, (sum(mpp_ft1.c1)), (sqrt((mpp_ft1.c1)::double precision))
                     Sort Key: mpp_ft1.c2, (sum(mpp_ft1.c1))
                     ->  Finalize HashAggregate
                           Output: mpp_ft1.c2, sum(mpp_ft1.c1), (sqrt((mpp_ft1.c1)::double precision))
                           Group Key: mpp_ft1.c2, (sqrt((mpp_ft1.c1)::double precision))
                           ->  Redistribute Motion 2:3  (slice2; segments: 2)
                                 Output: mpp_ft1.c2, (sqrt((mpp_ft1.c1)::double precision)), (PARTIAL sum(mpp_ft1.c1))
                                 Hash Key: mpp_ft1.c2, (sqrt((mpp_ft1.c1)::double precision))
                                 ->  Foreign Scan
                                       Output: mpp_ft1.c2, (sqrt((mpp_ft1.c1)::double precision)), (PARTIAL sum(mpp_ft1.c1))
                                       Relations: Aggregate on (public.mpp_ft1)
                                       Remote SQL: SELECT c2, sqrt(c1), sum(c1) FROM "MPP_S 1"."T 1" GROUP BY 1, 2
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(21 rows)

SELECT count(x.a), sum(x.a) FROM (SELECT c2 a, sum(c1) b FROM mpp_ft1 GROUP BY c2, sqrt(c1) ORDER BY 1, 2) x;
 count | sum  
-------+------
  1000 | 4500
(1 row)

-- Aggregate is still pushed down by taking unshippable expression out
EXPLAIN (VERBOSE, COSTS OFF)
SELECT c2 * (random() <= 1)::int as sum1, sum(c1) * c2 as sum2 FROM mpp_ft1 GROUP BY c2 ORDER BY 1, 2;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: ((c2 * ((random() <= '1'::double precision))::integer)), ((sum(c1) * c2)), c2
   Merge Key: ((c2 * ((random() <= '1'::double precision))::integer)), ((sum(c1) * c2))
   ->  Sort
         Output: ((c2 * ((random() <= '1'::double precision))::integer)), ((sum(c1) * c2)), c2
         Sort Key: ((mpp_ft1.c2 * ((random() <= '1'::double precision))::integer)), ((sum(mpp_ft1.c1) * mpp_ft1.c2))
         ->  Finalize HashAggregate
               Output: (c2 * ((random() <= '1'::double precision))::integer), (sum(c1) * c2), c2
               Group Key: mpp_ft1.c2
               ->  Redistribute Motion 2:3  (slice2; segments: 2)
                     Output: c2, (PARTIAL sum(c1))
                     Hash Key: c2
                     ->  Foreign Scan
                           Output: c2, (PARTIAL sum(c1))
                           Relations: Aggregate on (public.mpp_ft1)
                           Remote SQL: SELECT c2, sum(c1) FROM "MPP_S 1"."T 1" GROUP BY 1
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(18 rows)

SELECT c2 * (random() <= 1)::int as sum1, sum(c1) * c2 as sum2 FROM mpp_ft1 GROUP BY c2 ORDER BY 1, 2;
 sum1 |  sum2  
------+--------
    0 |      0
    1 |  49600
    2 |  99400
    3 | 149400
    4 | 199600
    5 | 250000
    6 | 300600
    7 | 351400
    8 | 402400
    9 | 453600
(10 rows)

-- Aggregate with unshippable GROUP BY clause are not pushed
EXPLAIN (VERBOSE, COSTS OFF)
SELECT c2 * (random() <= 1)::int as c2 FROM mpp_ft1 GROUP BY c2 * (random() <= 1)::int ORDER BY 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: ((c2 * ((random() <= '1'::double precision))::integer))
   Merge Key: ((c2 * ((random() <= '1'::double precision))::integer))
   ->  Sort
         Output: ((c2 * ((random() <= '1'::double precision))::integer))
         Sort Key: ((mpp_ft1.c2 * ((random() <= '1'::double precision))::integer))
         ->  HashAggregate
               Output: ((c2 * ((random() <= '1'::double precision))::integer))
               Group Key: ((mpp_ft1.c2 * ((random() <= '1'::double precision))::integer))
               ->  Redistribute Motion 2:3  (slice2; segments: 2)
                     Output: ((c2 * ((random() <= '1'::double precision))::integer))
                     Hash Key: ((c2 * ((random() <= '1'::double precision))::integer))
                     ->  HashAggregate
                           Output: ((c2 * ((random() <= '1'::double precision))::integer))
                           Group Key: (mpp_ft1.c2 * ((random() <= '1'::double precision))::integer)
                           ->  Foreign Scan on public.mpp_ft1
                                 Output: (c2 * ((random() <= '1'::double precision))::integer)
                                 Remote SQL: SELECT c2 FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(20 rows)

SELECT c2 * (random() <= 1)::int as c2 FROM mpp_ft1 GROUP BY c2 * (random() <= 1)::int ORDER BY 1;
 c2 
----
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
(10 rows)

-- GROUP BY clause in various forms, cardinal, alias and constant expression
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(c2) w, c2 x, 5 y, 7.0 z FROM mpp_ft1 GROUP BY 2, y, 9.0::int ORDER BY 2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: (count(c2)), c2, 5, 7.0, 9
   Merge Key: c2
   ->  Sort
         Output: (count(c2)), c2, 5, 7.0, 9
         Sort Key: mpp_ft1.c2
         ->  Finalize HashAggregate
               Output: count(c2), c2, (5), 7.0, (9)
               Group Key: mpp_ft1.c2, 5, 9
               ->  Redistribute Motion 2:3  (slice2; segments: 2)
                     Output: c2, 5, 9, (PARTIAL count(c2))
                     Hash Key: c2, 5, 9
                     ->  Foreign Scan
                           Output: c2, 5, 9, (PARTIAL count(c2))
                           Relations: Aggregate on (public.mpp_ft1)
                           Remote SQL: SELECT c2, 5, 9, count(c2) FROM "MPP_S 1"."T 1" GROUP BY 1, 2, 3
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(18 rows)

SELECT count(c2) w, c2 x, 5 y, 7.0 z FROM mpp_ft1 GROUP BY 2, y, 9.0::int ORDER BY 2;
  w  | x | y |  z  
-----+---+---+-----
 100 | 0 | 5 | 7.0
 100 | 1 | 5 | 7.0
 100 | 2 | 5 | 7.0
 100 | 3 | 5 | 7.0
 100 | 4 | 5 | 7.0
 100 | 5 | 5 | 7.0
 100 | 6 | 5 | 7.0
 100 | 7 | 5 | 7.0
 100 | 8 | 5 | 7.0
 100 | 9 | 5 | 7.0
(10 rows)

-- GROUP BY clause referring to same column multiple times
-- Also, ORDER BY contains an aggregate function
EXPLAIN (VERBOSE, COSTS OFF)
SELECT c2, c2 FROM mpp_ft1 WHERE c2 > 6 GROUP BY 1, 2 ORDER BY sum(c1);
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c2, c2, (sum(c1))
   Merge Key: (sum(c1))
   ->  Sort
         Output: c2, c2, (sum(c1))
         Sort Key: (sum(mpp_ft1.c1))
         ->  Finalize HashAggregate
               Output: c2, c2, sum(c1)
               Group Key: mpp_ft1.c2, mpp_ft1.c2
               ->  Redistribute Motion 2:3  (slice2; segments: 2)
                     Output: c2, c2, (PARTIAL sum(c1))
                     Hash Key: c2, c2
                     ->  Foreign Scan
                           Output: c2, c2, (PARTIAL sum(c1))
                           Relations: Aggregate on (public.mpp_ft1)
                           Remote SQL: SELECT c2, c2, sum(c1) FROM "MPP_S 1"."T 1" WHERE ((c2 > 6)) GROUP BY 1, 2
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(18 rows)

SELECT c2, c2 FROM mpp_ft1 WHERE c2 > 6 GROUP BY 1, 2 ORDER BY sum(c1);
 c2 | c2 
----+----
  7 |  7
  8 |  8
  9 |  9
(3 rows)

-- Testing HAVING clause
-- It's unsafe for partial agg to push down HAVING clause.
EXPLAIN (VERBOSE, COSTS OFF)
SELECT c2, sum(c1) FROM mpp_ft1 GROUP BY c2 HAVING avg(c1) < 500 AND sum(c1) < 49800 ORDER BY c2;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c2, (sum(c1))
   Merge Key: c2
   ->  Sort
         Output: c2, (sum(c1))
         Sort Key: mpp_ft1.c2
         ->  Finalize HashAggregate
               Output: c2, sum(c1)
               Group Key: mpp_ft1.c2
               Filter: ((avg(mpp_ft1.c1) < '500'::numeric) AND (sum(mpp_ft1.c1) < 49800))
               ->  Redistribute Motion 2:3  (slice2; segments: 2)
                     Output: c2, (PARTIAL sum(c1)), (PARTIAL avg(c1))
                     Hash Key: c2
                     ->  Partial HashAggregate
                           Output: c2, PARTIAL sum(c1), PARTIAL avg(c1)
                           Group Key: mpp_ft1.c2
                           ->  Foreign Scan on public.mpp_ft1
                                 Output: c1, c2, c3, c4, c5, c6, c7
                                 Remote SQL: SELECT c1, c2 FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(21 rows)

SELECT c2, sum(c1) FROM mpp_ft1 GROUP BY c2 HAVING avg(c1) < 500 AND sum(c1) < 49800 ORDER BY c2;
 c2 |  sum  
----+-------
  1 | 49600
  2 | 49700
(2 rows)

-- Remote aggregate in combination with a local Param (for the output
-- of an initplan) can be trouble, per bug #15781
EXPLAIN (VERBOSE, COSTS OFF)
SELECT exists(SELECT 1 FROM pg_aggregate), sum(c1) FROM mpp_ft1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Finalize Aggregate
   Output: $0, sum(mpp_ft1.c1)
   InitPlan 1 (returns $0)  (slice2)
     ->  Seq Scan on pg_catalog.pg_aggregate
           Output: 1
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL sum(mpp_ft1.c1))
         ->  Foreign Scan
               Output: (PARTIAL sum(mpp_ft1.c1))
               Relations: Aggregate on (public.mpp_ft1)
               Remote SQL: SELECT sum(c1) FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(13 rows)

SELECT exists(SELECT 1 FROM pg_aggregate), sum(c1) FROM mpp_ft1;
 exists |  sum   
--------+--------
 t      | 500500
(1 row)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT exists(SELECT 1 FROM pg_aggregate), sum(c1) FROM mpp_ft1 group by 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Finalize GroupAggregate
   Output: ($0), sum(mpp_ft1.c1)
   Group Key: ($0)
   InitPlan 1 (returns $0)  (slice2)
     ->  Seq Scan on pg_catalog.pg_aggregate
           Output: 1
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: ($0), (PARTIAL sum(mpp_ft1.c1))
         ->  Partial GroupAggregate
               Output: ($0), PARTIAL sum(mpp_ft1.c1)
               Group Key: $0
               ->  Foreign Scan on public.mpp_ft1
                     Output: $0, mpp_ft1.c1
                     Remote SQL: SELECT c1 FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(16 rows)

SELECT exists(SELECT 1 FROM pg_aggregate), sum(c1) FROM mpp_ft1 group by 1;
 exists |  sum   
--------+--------
 t      | 500500
(1 row)

-- Testing ORDER BY, DISTINCT, FILTER within aggregates
-- ORDER BY within aggregate, same column used to order
-- TODO: Now we don't support array_agg mpp pushdown.
EXPLAIN (VERBOSE, COSTS OFF)
SELECT array_agg(c1 ORDER BY c1) FROM mpp_ft1 WHERE c1 < 100 GROUP BY c2 ORDER BY 1;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(c1 ORDER BY c1)), c2
   Sort Key: (array_agg(mpp_ft1.c1 ORDER BY mpp_ft1.c1))
   ->  GroupAggregate
         Output: array_agg(c1 ORDER BY c1), c2
         Group Key: mpp_ft1.c2
         ->  Gather Motion 2:1  (slice1; segments: 2)
               Output: c2, c1
               Merge Key: c2
               ->  Foreign Scan on public.mpp_ft1
                     Output: c2, c1
                     Remote SQL: SELECT c1, c2 FROM "MPP_S 1"."T 1" WHERE ((c1 < 100)) ORDER BY c2 ASC NULLS LAST
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(14 rows)

SELECT array_agg(c1 ORDER BY c1) FROM mpp_ft1 WHERE c1 < 100 GROUP BY c2 ORDER BY 1;
           array_agg            
--------------------------------
 {1,11,21,31,41,51,61,71,81,91}
 {2,12,22,32,42,52,62,72,82,92}
 {3,13,23,33,43,53,63,73,83,93}
 {4,14,24,34,44,54,64,74,84,94}
 {5,15,25,35,45,55,65,75,85,95}
 {6,16,26,36,46,56,66,76,86,96}
 {7,17,27,37,47,57,67,77,87,97}
 {8,18,28,38,48,58,68,78,88,98}
 {9,19,29,39,49,59,69,79,89,99}
 {10,20,30,40,50,60,70,80,90}
(10 rows)

-- FILTER within aggregate
EXPLAIN (VERBOSE, COSTS OFF)
SELECT sum(c1) FILTER (WHERE c1 < 100 AND c2 > 5) FROM mpp_ft1 GROUP BY c2 ORDER BY 1 nulls last;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: (sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5)))), c2
   Merge Key: (sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5))))
   ->  Sort
         Output: (sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5)))), c2
         Sort Key: (sum(mpp_ft1.c1) FILTER (WHERE ((mpp_ft1.c1 < 100) AND (mpp_ft1.c2 > 5))))
         ->  Finalize HashAggregate
               Output: sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5))), c2
               Group Key: mpp_ft1.c2
               ->  Redistribute Motion 2:3  (slice2; segments: 2)
                     Output: c2, (PARTIAL sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5))))
                     Hash Key: c2
                     ->  Foreign Scan
                           Output: c2, (PARTIAL sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5))))
                           Relations: Aggregate on (public.mpp_ft1)
                           Remote SQL: SELECT c2, sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5))) FROM "MPP_S 1"."T 1" GROUP BY 1
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(18 rows)

SELECT sum(c1) FILTER (WHERE c1 < 100 AND c2 > 5) FROM mpp_ft1 GROUP BY c2 ORDER BY 1 nulls last;
 sum 
-----
 510
 520
 530
 540
    
    
    
    
    
    
(10 rows)

-- DISTINCT, ORDER BY and FILTER within aggregate
-- It's unsafe to push down DISTINCT within aggregates for mpp_execute = 'all segments'.
EXPLAIN (VERBOSE, COSTS OFF)
SELECT sum(c1%3), sum(DISTINCT c1%3 ORDER BY c1%3) FILTER (WHERE c1%3 < 2), c2 FROM mpp_ft1 WHERE c2 = 6 GROUP BY c2;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: (sum((c1 % 3))), (sum(DISTINCT (c1 % 3) ORDER BY (c1 % 3)) FILTER (WHERE ((c1 % 3) < 2))), c2
   ->  GroupAggregate
         Output: sum((c1 % 3)), sum(DISTINCT (c1 % 3) ORDER BY (c1 % 3)) FILTER (WHERE ((c1 % 3) < 2)), c2
         Group Key: mpp_ft1.c2
         ->  Redistribute Motion 2:3  (slice2; segments: 2)
               Output: c2, c1
               Hash Key: c2
               ->  Foreign Scan on public.mpp_ft1
                     Output: c2, c1
                     Remote SQL: SELECT c1, c2 FROM "MPP_S 1"."T 1" WHERE ((c2 = 6))
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(13 rows)

SELECT sum(c1%3), sum(DISTINCT c1%3 ORDER BY c1%3) FILTER (WHERE c1%3 < 2), c2 FROM mpp_ft1 WHERE c2 = 6 GROUP BY c2;
 sum | sum | c2 
-----+-----+----
  99 |   1 |  6
(1 row)

-- Aggregate not pushed down as FILTER condition is not pushable
EXPLAIN (VERBOSE, COSTS OFF)
SELECT sum(c1) FILTER (WHERE (c1 / c1) * random() <= 1) FROM mpp_ft1 GROUP BY c2 ORDER BY 1;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: (sum(c1) FILTER (WHERE ((((c1 / c1))::double precision * random()) <= '1'::double precision))), c2
   Merge Key: (sum(c1) FILTER (WHERE ((((c1 / c1))::double precision * random()) <= '1'::double precision)))
   ->  Sort
         Output: (sum(c1) FILTER (WHERE ((((c1 / c1))::double precision * random()) <= '1'::double precision))), c2
         Sort Key: (sum(mpp_ft1.c1) FILTER (WHERE ((((mpp_ft1.c1 / mpp_ft1.c1))::double precision * random()) <= '1'::double precision)))
         ->  Finalize HashAggregate
               Output: sum(c1) FILTER (WHERE ((((c1 / c1))::double precision * random()) <= '1'::double precision)), c2
               Group Key: mpp_ft1.c2
               ->  Redistribute Motion 2:3  (slice2; segments: 2)
                     Output: c2, (PARTIAL sum(c1) FILTER (WHERE ((((c1 / c1))::double precision * random()) <= '1'::double precision)))
                     Hash Key: c2
                     ->  Partial HashAggregate
                           Output: c2, PARTIAL sum(c1) FILTER (WHERE ((((c1 / c1))::double precision * random()) <= '1'::double precision))
                           Group Key: mpp_ft1.c2
                           ->  Foreign Scan on public.mpp_ft1
                                 Output: c1, c2, c3, c4, c5, c6, c7
                                 Remote SQL: SELECT c1, c2 FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(20 rows)

SELECT sum(c1) FILTER (WHERE (c1 / c1) * random() <= 1) FROM mpp_ft1 GROUP BY c2 ORDER BY 1;
  sum  
-------
 49600
 49700
 49800
 49900
 50000
 50100
 50200
 50300
 50400
 50500
(10 rows)

-- Set use_remote_estimate to true
ALTER FOREIGN TABLE mpp_ft1 OPTIONS(add use_remote_estimate 'true');
EXPLAIN (VERBOSE, COSTS OFF)
SELECT min(c5) FROM mpp_ft1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Finalize Aggregate
   Output: min(c5)
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL min(c5))
         ->  Foreign Scan
               Output: (PARTIAL min(c5))
               Relations: Aggregate on (public.mpp_ft1)
               Remote SQL: SELECT min(c5) FROM "MPP_S 1"."T 1"
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(10 rows)

SELECT min(c5) FROM mpp_ft1;
  min  
-------
 0.001
(1 row)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(c1), max(c6) FROM mpp_ft1 GROUP BY c2;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Output: count(c1), max(c6), c2
   Group Key: mpp_ft1.c2
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: c2, (PARTIAL count(c1)), (PARTIAL max(c6))
         Merge Key: c2
         ->  Sort
               Output: c2, (PARTIAL count(c1)), (PARTIAL max(c6))
               Sort Key: mpp_ft1.c2
               ->  Foreign Scan
                     Output: c2, (PARTIAL count(c1)), (PARTIAL max(c6))
                     Relations: Aggregate on (public.mpp_ft1)
                     Remote SQL: SELECT c2, count(c1), max(c6) FROM "MPP_S 1"."T 1" GROUP BY 1
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(15 rows)

SELECT count(c1), max(c6) FROM mpp_ft1 GROUP BY c2;
 count |  max  
-------+-------
   100 |     1
   100 | 0.991
   100 | 0.992
   100 | 0.993
   100 | 0.994
   100 | 0.995
   100 | 0.996
   100 | 0.997
   100 | 0.998
   100 | 0.999
(10 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(c1), sum(c3), avg(c4), min(c5), max(c6), count(c1) * (random() <= 1)::int as count2 FROM mpp_ft1 GROUP BY c2 ORDER BY c2;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Output: count(c1), sum(c3), avg(c4), min(c5), max(c6), (count(c1) * ((random() <= '1'::double precision))::integer), c2
   Group Key: mpp_ft1.c2
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: c2, (PARTIAL count(c1)), (PARTIAL sum(c3)), (PARTIAL avg(c4)), (PARTIAL min(c5)), (PARTIAL max(c6))
         Merge Key: c2
         ->  Sort
               Output: c2, (PARTIAL count(c1)), (PARTIAL sum(c3)), (PARTIAL avg(c4)), (PARTIAL min(c5)), (PARTIAL max(c6))
               Sort Key: mpp_ft1.c2
               ->  Foreign Scan
                     Output: c2, (PARTIAL count(c1)), (PARTIAL sum(c3)), (PARTIAL avg(c4)), (PARTIAL min(c5)), (PARTIAL max(c6))
                     Relations: Aggregate on (public.mpp_ft1)
                     Remote SQL: SELECT c2, count(c1), sum(c3), array[count(c4), sum(c4)], min(c5), max(c6) FROM "MPP_S 1"."T 1" GROUP BY 1
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(15 rows)

SELECT count(c1), sum(c3), avg(c4), min(c5), max(c6), count(c1) * (random() <= 1)::int as count2 FROM mpp_ft1 GROUP BY c2 ORDER BY c2;
 count |  sum  |         avg          |  min  |  max  | count2 
-------+-------+----------------------+-------+-------+--------
   100 | 50500 | 505.0000000000000000 |  0.01 |     1 |    100
   100 | 49600 | 496.0000000000000000 | 0.001 | 0.991 |    100
   100 | 49700 | 497.0000000000000000 | 0.002 | 0.992 |    100
   100 | 49800 | 498.0000000000000000 | 0.003 | 0.993 |    100
   100 | 49900 | 499.0000000000000000 | 0.004 | 0.994 |    100
   100 | 50000 | 500.0000000000000000 | 0.005 | 0.995 |    100
   100 | 50100 | 501.0000000000000000 | 0.006 | 0.996 |    100
   100 | 50200 | 502.0000000000000000 | 0.007 | 0.997 |    100
   100 | 50300 | 503.0000000000000000 | 0.008 | 0.998 |    100
   100 | 50400 | 504.0000000000000000 | 0.009 | 0.999 |    100
(10 rows)

ALTER FOREIGN TABLE mpp_ft1 OPTIONS(set use_remote_estimate 'false');
-- limit is not pushed down when mpp_execute is set to 'all segments'
-- limit with agg functions
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(c1), max(c6) FROM mpp_ft1 GROUP BY c2 order by c2 limit 3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (count(c1)), (max(c6)), c2
   ->  Finalize GroupAggregate
         Output: count(c1), max(c6), c2
         Group Key: mpp_ft1.c2
         ->  Gather Motion 2:1  (slice1; segments: 2)
               Output: c2, (PARTIAL count(c1)), (PARTIAL max(c6))
               Merge Key: c2
               ->  Partial GroupAggregate
                     Output: c2, PARTIAL count(c1), PARTIAL max(c6)
                     Group Key: mpp_ft1.c2
                     ->  Foreign Scan on public.mpp_ft1
                           Output: c1, c2, c3, c4, c5, c6, c7
                           Remote SQL: SELECT c1, c2, c6 FROM "MPP_S 1"."T 1" ORDER BY c2 ASC NULLS LAST
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(16 rows)

SELECT count(c1), max(c6) FROM mpp_ft1 GROUP BY c2 order by c2 limit 3;
 count |  max  
-------+-------
   100 |     1
   100 | 0.991
   100 | 0.992
(3 rows)

-- limit with normal scan without agg functions
EXPLAIN (VERBOSE, COSTS OFF)
SELECT c1, c2 FROM mpp_ft1 order by c1 limit 3;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: c1, c2
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: c1, c2
         Merge Key: c1
         ->  Limit
               Output: c1, c2
               ->  Foreign Scan on public.mpp_ft1
                     Output: c1, c2
                     Remote SQL: SELECT c1, c2 FROM "MPP_S 1"."T 1" ORDER BY c1 ASC NULLS LAST
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(12 rows)

SELECT c1, c2 FROM mpp_ft1 order by c1 limit 3;
 c1 | c2 
----+----
  1 |  1
  2 |  2
  3 |  3
(3 rows)

-- join is not safe to pushed down when mpp_execute is set to 'all segments'
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(*), sum(t1.c1), avg(t2.c2) FROM mpp_ft1 t1 inner join mpp_ft1 t2 on (t1.c1 = t2.c1) where t1.c1 = 2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(*), sum(t1.c1), avg(t2.c2)
   ->  Gather Motion 2:1  (slice1; segments: 2)
         Output: (PARTIAL count(*)), (PARTIAL sum(t1.c1)), (PARTIAL avg(t2.c2))
         ->  Partial Aggregate
               Output: PARTIAL count(*), PARTIAL sum(t1.c1), PARTIAL avg(t2.c2)
               ->  Nested Loop
                     Output: t1.c1, t2.c2
                     ->  Broadcast Motion 2:2  (slice2; segments: 2)
                           Output: t1.c1
                           ->  Foreign Scan on public.mpp_ft1 t1
                                 Output: t1.c1
                                 Remote SQL: SELECT c1 FROM "MPP_S 1"."T 1" WHERE ((c1 = 2))
                     ->  Materialize
                           Output: t2.c2, t2.c1
                           ->  Foreign Scan on public.mpp_ft1 t2
                                 Output: t2.c2, t2.c1
                                 Remote SQL: SELECT c1, c2 FROM "MPP_S 1"."T 1" WHERE ((c1 = 2))
 Optimizer: Postgres query optimizer
 Settings: gp_enable_minmax_optimization = 'off', optimizer = 'off'
(20 rows)

SELECT count(*), sum(t1.c1), avg(t2.c2) FROM mpp_ft1 t1 inner join mpp_ft1 t2 on (t1.c1 = t2.c1) where t1.c1 = 2;
 count | sum |        avg         
-------+-----+--------------------
     1 |   2 | 2.0000000000000000
(1 row)

-- ===================================================================
-- Insert, update and delete
-- ===================================================================
INSERT INTO mpp_ft2 SELECT id, id % 5 FROM generate_series(1, 10) as id;
SELECT * FROM mpp_ft2 ORDER BY c1;
 c1 | c2 
----+----
  1 |  1
  2 |  2
  3 |  3
  4 |  4
  5 |  0
  6 |  1
  7 |  2
  8 |  3
  9 |  4
 10 |  0
(10 rows)

UPDATE mpp_ft2 SET c1 = 0 WHERE c2 = 0;
SELECT * FROM mpp_ft2 ORDER BY c1;
 c1 | c2 
----+----
  0 |  0
  0 |  0
  1 |  1
  2 |  2
  3 |  3
  4 |  4
  6 |  1
  7 |  2
  8 |  3
  9 |  4
(10 rows)

DELETE FROM mpp_ft2;
SELECT * FROM mpp_ft2 ORDER BY c1;
 c1 | c2 
----+----
(0 rows)

-- ===================================================================
-- When mpp_execute = 'multi servers', we don't support IMPORT FOREIGN SCHEMA
-- ===================================================================
CREATE SCHEMA mpp_import_dest;
IMPORT FOREIGN SCHEMA import_source FROM SERVER pgserver INTO mpp_import_dest;
ERROR:  If mpp_execute = "multi servers", it doesn't support import foreign schema
